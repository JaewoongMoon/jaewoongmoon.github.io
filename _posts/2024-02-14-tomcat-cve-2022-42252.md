---
layout: post
title: "톰캣 HTTP Request Smuggling 취약점을 동적 디버깅을 통해 분석하기"
categories: [보안취약점, 톰캣, HTTP Request Smuggling, CVE-2022-42252]
tags: [보안취약점, 톰캣, HTTP Request Smuggling, CVE-2022-42252]
toc: true
last_modified_at: 2024-02-14 18:15:00 +0900
---

# 개요
톰캣에 존재했던 HTTP Request Smuggling 취약점(CVE-2022-42252)을 동적 디버깅을 통해 취약점의 존재를 확인해본다. 패치 전의 소스코드로 구동되는 상태에서 스캔 툴을 돌려서 취약점의 존재를 확인하고, 패치 후의 소스코드로 구동해서 스캔 툴을 돌렸을 때 취약점이 없어졌는지 확인하는 것이다. 

간단히 말하면 아래와 같은 것을 어떻게 하는지 정리해둔다. 

![톰캣 동적 디버깅 결과](/images/tomcat-hrs-debugging.png)

출처: https://insbug.medium.com/apache-tomcat-request-smuggling-vulnerability-cve-2022-42252-836cb4bcb3d

# 취약점 개요
- HTTP Request Smuggling중에서 CL.0 패턴이다. 전단의 서버는 CL(Content-Length) 헤더를 보지만, 뒷단의 서버(톰캣)는 CL헤더를 보지 않기 때문에(CL헤더의 값이 0 바이트인 것처럼 행동) 양자간에 어디부터 어디까지가 HTTP요청의 시작과 끝인지 해석에 차이가 발생한다. 

## 취약점 발생 조건
- 톰캣앞에 다른 서버 (nginx나 Apache와 같은 웹서버 혹은 WAF나 로드밸런서 등)가 있어야 한다. 이 서버는 CL헤더를 인식해야 한다.
- 톰캣에서 `rejectIllegalHeader`설정이 false로 되어 있어야 한다. 이는 이상한 헤더가 있어도 거절하지 않고 처리한다는 의미다. 
- 그 결과 톰캣이 이상한 CL헤더를 만나면 이 헤더자체를 지운다. (CL헤더가 없는 것처럼 혹은 CL헤더 값이 0인 것처럼 동작한다.)
- 톰캣 8.5.x 에서는 이 값이 기본으로 false이다. 따라서 기본적으로 취약하다. 

# STEP 1. 톰캣에서 관련 소스코드 찾기 
먼저 취약점이 수정된 부분의 소스코드를 알아내야 한다. 소스 코드 추적방법을 정리해둔다. 

## 방법 1. 구글 검색이나 CVE 관련 링크에서 찾기 
구글에서 검색해보면 Snyk에서 제공하는 취약점 상세 페이지가 결과에 표시된다. 여기에 들어가면 Commit링크를 볼 수 있다. 

![Snyk 상세 페이지](/images/cve-2022-42252-snyk-link.png)

이 Commit링크는 Tomcat 버전 11 수정용 커밋링크였다. 

Tomcat 버전 11 수정용 커밋링크: https://github.com/apache/tomcat/commit/c9fe754e5d17e262dfbd3eab2a03ca96ff372dc3


## 방법 2. git 커밋 메세지에서 찾기 
커밋메시지로 찾는 방법이다. 개발자가 친절하다면 커밋 메세지에 CVE번호를 적었을 수도 있다. CVE번호가 아니라면 특정 키워드로 찾는다.

커밋메세지에서 찾는 커맨드는 다음과 같다. 대소문자를 구별하므로 적절히 변경하가면서 찾는다. 

```sh
git log --grep=키워드
git log --grep=CVE-2022-42252
git log --grep=Content-Length
git log --grep=content-length
```

키워드가 일치하는 것이 있으면 결과에 표시된다. 시간상으로 새로운 것이 위에 표시된다. CVE DB를 보면 취약점이 발표된 날을 볼 수 있다. 대략 이 날짜와 일치하는 부분의 코드를 찾는다. 예를들어 이번 분석 타겟인 `CVE-2022-42252`는 2022년 11월 1일에 NVD에 등록된 것으로 나온다. 

`content-length`키워드로 검색하면 2022년 11월에 가장 가까운 commit은 `a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a` 다. 커밋메세지도 `Requests with invalid content-length should always be rejected`인 것을 보면 내용도 맞는 것 같다. 

```sh
 git log --grep=content-length
commit 5dbfefa88293078d578c72e3ff17c4da5389110e
Author: remm <remm@apache.org>
Date:   Wed Oct 11 09:41:14 2023 +0200

    Revert compression refactoring

    BZ 67670
    Add test case to verify content-length is not present when using the
    connector compression (also that checks DefaultServlet is working with
    it).

commit a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a
Author: Mark Thomas <markt@apache.org>
Date:   Mon Oct 3 11:59:01 2022 +0100

    Requests with invalid content-length should always be rejected

commit 4d08ac6b5f490223adc4ea37930116852cc9fadd
Author: Mark Thomas <markt@apache.org>
Date:   Wed Jun 16 11:45:42 2021 +0100

    Fix test broken by response buffer fixes

    The 8192 byte response body fills the response buffer but does not (now)
    trigger a commit so Tomcat is able to set the content-length header in
    post-processing.

...
```

`https://github.com/apache/tomcat/commit/a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a` 에 접근하면 소스코드를 볼 수 있다! 

![소스 수정 상세](/images/cve-2022-42252-git-commit-log.png)

# STEP 2. 수정직전의 소스코드 커밋 ID 확인 

`git log 커밋ID` 커맨드를 사용하면 이 커밋직전의 커밋들을 볼 수 있다. 

```sh
$git log a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a
commit a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a
Author: Mark Thomas <markt@apache.org>
Date:   Mon Oct 3 11:59:01 2022 +0100

    Requests with invalid content-length should always be rejected

commit 75d11526eff3e590490288b89d17fe1903e7da9a
Author: Mark Thomas <markt@apache.org>
Date:   Fri Sep 30 20:19:42 2022 +0100

    Update RewriteValve to use dotall mode

commit b01c241e56cec904d3cd9fa00c9a2bc0b6831bbc
Author: Mark Thomas <markt@apache.org>
Date:   Fri Sep 30 18:17:14 2022 +0100

    BZ 66281 - unexpected timeouts when using HTTP/2 and NIO2

    Timeouts may appear as client disconnections
    https://bz.apache.org/bugzilla/show_bug.cgi?id=66281
```

커밋ID `a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a`의 직전 커밋은 `75d11526eff3e590490288b89d17fe1903e7da9a`인 것을 알았다. 


# STEP 3. 톰캣의 소스코드를  취약했던 시점의 소스코드로 돌린다. 
특정 commit 시점으로 소스코드를 되돌리는 방법은 [여기](https://stackoverflow.com/questions/4372435/how-can-i-rollback-a-git-repository-to-a-specific-commit)에서 확인할 수 있다. 

```sh
git reset --hard <old-commit-id>
git push -f <remote-name> <branch-name>
```

다음 커맨드를 사용했다. 취약한 시점으로 돌려야 하므로 수정 직전의 커밋ID를 지정한다. 

```sh
git reset --hard 75d11526eff3e590490288b89d17fe1903e7da9a
```

현재 커밋 위치를 확인하는 방법은?

# STEP 4. 취약했던 프로그램의 소스코드 라인을 알아내어 브레이크 포인트를 찍는다. 
이건 힌트가 있다. 취약점 POC 페이지를 보면 테스트용 파일 TestHttp11InputBuffer.java 에 브레이크 포인트가 찍혀있는 것을 볼 수 있다. (commit 변경사항에 보면 취약점이 있었던 파일 `TestHttp11InputBuffer.java`와 함께 `TestHttp11InputBuffer.java` 파일이 같이 커밋된 것을 알 수 있다.)

## 소스코드 분석

TestHttp11InputBuffer 클래스안에 있는 `parseHeader` 함수(852라인~1043라인)가 메인이다. 이 함수에는 HTTP요청헤더를 어떻게 처리할 것인지에 대한 코드가 적혀있다. 


## 참고. 테스트 파일 실행방법

`TestHttp11InputBuffer.java`는 유닛테스트 코드가 적혀있다. Eclipse 에서는 실행버튼을 누르면 알아서 Junit을 실행해준다. 

유닛테스트 실행 결과는 다음과 같다. 

![유닛테스트 실행 결과 샘플](/images/cve-2022-42252-junit-test-sample.png)


# STEP 5. 취약점 수정 전 소스로 톰캣을 구동하고, 공격용 페이로드를 보내서 HTTP 요청이 어떻게 처리되는지 확인한다. (취약점 존재 확인)

여기에서 좀 막히고 있다. 

Burp Suite로 CL헤더의 값에 본래는 들어갈 수 없는 값 ([여기](https://onlinetools.com/unicode/convert-unicode-to-bytes)에서 유니코드로 "한"이라는 한글을 인코딩한 `0xed 0x95 0x9c`)을 넣었다.

![CL헤더 이상한 값 넣기](/images/cve-2022-42252-poc-1.png)

톰캣 서버에서 브레이크 포인트를 찍어서 확인해보면 제대로 유니코드 바이트가 들어온 것처럼 보인다. 

![톰캣 서버 값 확인](/images/cve-2022-42252-poc-2.png)

그런데 돌아오는 응답을 보면 400응답이다. (POC페이지를 보면 200응답이어야 하는데.. 뭔가 놓치고 있는 부분이 있을지도 모른다.)

![톰캣 서버 400응답](/images/cve-2022-42252-poc-3.png)

여기 코드가 동작하는지도 모른다. 

![의심점](/images/cve-2022-42252-400-reason-1.png)

## 로그를 Debug 모드로 운용
conf/logging.properties 파일의 로깅 레벨을 가장 상세한 레벨인 `FINEST`로 지정하고 ant로 빌드한후 서버를 재구동해봤지만 먹히지 않았다. 다른 방법을 찾아봐야한다. 

[여기](https://cwiki.apache.org/confluence/display/TOMCAT/Logging)를 참고해본다. 

# STEP 6. 취약점 수정 후 소스로 톰캣을 구동하고, 공격용 페이로드를 보내서 HTTP 요청이 어떻게 처리되는지 확인한다. (취약점이 수정된 것을 확인)




# 참고
- 취약점 정보: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-42252
- 취약점 POC: https://insbug.medium.com/apache-tomcat-request-smuggling-vulnerability-cve-2022-42252-836cb4bcb3d
- 톰캣 설정: https://tomcat.apache.org/tomcat-8.5-doc/config/http.html
- 취약점 수정 코드: https://github.com/apache/tomcat/commit/a1c07906d8dcaf7957e5cc97f5cdbac7d18a205a
- 로깅레벨: https://docs.oracle.com/javase/jp/6/api/java/util/logging/Level.html