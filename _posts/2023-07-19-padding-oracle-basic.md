---
layout: post
title: "패딩 오라클(Padding Oracle) 취약점정리"
categories: [보안취약점, 암호관련취약점, 패딩오라클, Padding Oracle]
tags: [보안취약점, 암호관련취약점, 패딩오라클, Padding Oracle]
toc: true
last_modified_at: 2023-07-21 14:02:00 +0900
---

# 개요 
- 패딩 오라클 취약점의 원리를 이해한 부분을 정리해둔다. 
- padding oracle은 2002년에 Serge Vaudenay가 처음 발표하였고, 이후 이 공격을 응용한 다양한 취약점들이 발표되고 있다. 그 중 유명한 것으로 2014년에 구글 엔지니어팀이 발표한 POODLE 취약점이 있다. 이 취약점을 악용하면 **암호키 없이도 평문을 얻어내는 것이 가능하다.** 
- 내가 패딩 오라클 취약점을 처음 알게된 것은 2017년이다. 이 시점에 CVE 데이터베이스에서 padding oracle로 검색해보면 24건이 조회되었다. 
- 2023년 7월에 다시한번 padding oracle로 검색해보니 50건이 조회되었다. 6년 사이에 26건이 추가된 것이다. 의외로 끊이지 않고 계속 발견되는 취약점이라는 것을 알 수 있다. 

# 사전지식
취약점을 이해하기 위해서 먼저 알아야 하는 개념을 정리한다. 패딩 오라클 취약점을 이해하려면 블록암호, 운용모드, 패딩 이렇게 세 가지에 대해서 개념을 잡고 있어야 한다. 

## 블록암호
블록암호란 평문을 일정사이즈(블록)로 분할해서 블록별로 암호화 처리를 하는 방식이다. 대표적으로 DES, AES 가 블록암호 방식의 알고리즘이다. 블록의 사이즈는 보통 64비트(8바이트)나 128비트(16바이트)가 사용된다. 블록암호는 각 블록을 같은 암호키로 암호화했을 경우 해독이 쉬워진다는 단점이 있다. 그래서 처리를 복잡하게 하고 암호의 강도를 높이기 위해 운용 모드가 개발되었다. 

## 운용모드
EBC, CBC, CFB, OFB 등 다양한 운용모드가 있지만 여기서는 EBC와 CBC 모드에 대해서만 설명한다. 

### ECB 모드
Electronic Code Book 의 약자로 평문을 블록으로 나눠서 각 블록을 암호화하는 방식이다. 각 블록이 독립적이므로 병행처리가 가능해 속도는 빠르지만 암호강도가 낮아서 **사용하면 안되는 방식이다.**　

이미지 출처: en.wikipedia.org/wiki/Block_cipher_mode_of_operation

![ECB 모드 암호화](/images/Ecb_encryption.png)

![ECB 모드 복호화](/images/Ecb_decryption.png)


이미지를 ECB 모드로 암호화했을 경우 다음과 같이 이미지의 윤곽이 그대로 보이게 된다. 이 것으로 ECB 모드의 암호화 강도는 낮다는 것을 알 수 있다. 

![ECB 모드 이미지](/images/Tux_ecb.jpg)

###  CBC 모드
Cipher Block Chaining 의 약자로 이전의 평문 블록의 암호결과와 다음 평문블록을 XOR한 결과를 암호화하는 방식이다. 1976년 IBM이 개발하였고, 첫번째 블록의 암호화에는 초기화 벡터(Initial Vector, IV)가 쓰인다. 초기화 벡터는 첫번째 블록의 입력 값으로 쓰이다. 암호의 강도가 높고, 널리 사용되고 있는 방식이다. 

이미지 출처: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation

![CBC 모드의 암호화 과정](/images/Cbc_encryption.png)

![CBC 모드의 복호화 과정](/images/Cbc_decryption.png)

## 패딩
패딩은 평문의 마지막 블록에서 블록 사이즈에 비해 모자란 부분을 채워주는 값이다. 예를 들어 블록 사이즈가 8바이트이고, 평문이 5바이트라면 3바이트를 패딩으로 채워주는 식이다. 다양한 운용모드 중에서 ECB, CBC 모드가 패딩을 사용한다. (이 모드들은 평문의 크기가 블록 사이즈의 배수여야 한다는 규칙이 있기 때문에 패딩을 사용한다.)

### PKCS#7
패딩은 여러가지 종류가 있지만 블록 암호에서는 PKCS#7 를 사용한다. 다음 그림이 8바이트 블록 암호화에서 패딩의 개념을 보여주고 있다. PKCS#7 패딩의 규칙은 패딩의 개수(바이트수)와 그 값이 일치해야 한다는 것이다. 예를 들어 패딩이 한 개일 경우는 패딩의 값도 0x01, 패딩이 두 개인 경우는 패딩의 값도 0x02 여야한다. 평문의 크기가 블록 크기와 동일한 경우를 어떨까? 그림에서 Ex4를 보면 8바이트 블록과 동일한 사이즈인 경우 8개의 패딩이 추가되는 것을 볼 수 있다. 이 것으로 평문과 블록이 동일한 사이즈인 경우에도 패딩이 추가된다는 것을 알 수 있다. 

이미지 출처: https://blog.gdssecurity.com/labs/2010/9/14/automated-padding-oracle-attacks-with-padbuster.html

![블록암호 패딩예시](/images/block-cipher-padding-example.png)

# 취약점 원리 

## 취약한 서버 사양
취약점의 원리를 설명하기 위해 다음과 같은 서버가 존재한다고 가정한다. 

- 이 서버에는 요청을 보내면 평문을 암호화하거나, 또는 암호화된 값을 복호화해주는 기능이 있다. 
- 이 서버는 복호화에 성공하면 복호화된 평문을 회신해준다. 
- 이 서버는 복호화에 실패해서 에러가 발생하면 에러를 그대로 회신해준다. 
- 이 서버는 암호 알고리즘으로 8바이트 블록을 사용하는 3DES를 사용한다. 
- 이 서버에는 패딩 오라클 취약점이 있다.  

## 시나리오 
이 서버에 평문 'my name is jwmoon'을 보냈더니 24바이트 암호문 '5F24DD35CC079BA9970DBA343DF81F5A444B28E091B8DF25' 을 회신해주었다. 이 암호문을 패딩 오라클 취약점을 이용해서 풀어본다. 

이해의 편의를 위해 헥스 값을 문자열로 변환해서 표현했다. 헥스 값 2개가 1 바이트를 의미한다. 

![암호문 얻기](/images/padding-oracle-encrypt-sample-2.png)


## 공격 수행 
패딩 오라클이 어떤 원리로 암호화된 값의 평문을 얻어내는지를 이해하기 위해서는 두 가지 단계를 "제대로" 이해해야 한다. 두 단계는 **복호화 과정**과 **패딩 규칙**이다. 

### 복호화 과정 이해 
원리를 이해하기 위한 첫번째 단계는 CBC모드의 복호화 과정을 확실하게 이해하는 것이다. 

복호화 과정을 다시 한번 살펴본다. 

![CBC 모드의 복호화 과정](/images/Cbc_decryption.png)

위의 복호화 과정을 예제 암호문의 복호화 과정에 적용해서 표현해보자. 

"my name is jwmoon" 을 암호화한 값 5F24DD35CC079BA9970DBA343DF81F5A444B28E091B8DF25 을 8바이트 단위로 쪼개면 다음과 같다. 
5F24DD35CC079BA9 970DBA343DF81F5A 444B28E091B8DF25

그리고 값을 알 수 없는 부분은 물음표(?)로 표현하면 다음과 같이 된다. 

![원리설명-1](/images/padding-oracle-principle-1.png)

그림의 첫번째 블록(Block 1)을 살펴보자. 

1. 가장 위쪽에 위치한 암호화된 바이트값을 나타낸다. 
2. Triple DES라고 표기된 부분을 복호화가 수행되는 것을 나타낸다. 
3. 복호화가 수행된 후의 값을 알 수 없으므로 물음표로 표현되었다. 
4. 복호화된 값과 이니셜 벡터(IV)의 값을 XOR한 결과가 my name 이라는 평문으로 표시되었다. (그림에서 동그라미에 +기호가 들어간 도형으로 표시된 곳이 XOR 연산을 하는 부분이다. )

CBC 모드 복호화 과정의 특징은 이전 블록의 암호화된 값이 현재 블록의 복호화에 사용된다는 것이다. 더 구체적으로는 **이전 블록의 암호화된 값과 현재 블록의 복호화된 값을 XOR한 값** 이 현재 블록의 평문이 된다는 것이다.

예를 들어 그림에서 Block3의 평문 값은 이전 암호 블록 값 8바이트와 (970DBA343DF81F5A)과 Block 3의 복호화된 값 8바이트 (????????) 를 XOR 한 값이다. 

따라서 **이전 블록의 특정 위치의 바이트 값을 변경하면 다음 블록의 평문값에 영향을 미친다** 는 것을 추론할 수 있다. 예를 들어 Block 2애서 암호화된 바이트의 마지막 값인 5A를 변경하면 Block 3의 평문의 마지막 바이트값에 영향을 미치게 된다. 

![원리설명-2](/images/padding-oracle-principle-2.png)
